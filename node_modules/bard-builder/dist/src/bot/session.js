"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const message_1 = __importStar(require("../gateway/message"));
const emitter_1 = require("./emitter");
const proxy_1 = require("../utils/proxy");
class Session {
    constructor(token, origin, state, gateway, emitter) {
        if (!token.length)
            throw new Error("Invalid or missing token string");
        if (!origin.length)
            throw new Error("Invalid or missing origin string");
        this.state = (0, proxy_1.toWatchable)(lodash_1.default.cloneDeep(state), {
            onUpdate: () => this.need_sync = true
        });
        this.need_sync = true;
        this.token = token;
        this.origin = origin;
        this.gateway = gateway;
        this.emitter = emitter;
        this.message = null;
        this.contact = "";
        this.vendor = "";
        this.active = false;
        this.status = true;
        this.progress = { current: { node: "", step: 0 }, detached: [] };
        this.timestamp = Math.floor(+new Date() / 1000);
    }
    isActive() {
        return this.active;
    }
    getStatus() {
        return this.status;
    }
    getProgress() {
        return this.progress;
    }
    getMessage() {
        return this.message || (0, message_1.createEmptyMessage)();
    }
    getContact() {
        return this.contact;
    }
    getVendor() {
        return this.vendor;
    }
    getStorageData() {
        return { progress: this.progress, state: this.state, timestamp: this.timestamp, expiration: Session.EXPIRATION };
    }
    isExpired() {
        return (Math.floor(+new Date() / 1000) > (this.timestamp + Session.EXPIRATION));
    }
    setActive(value) {
        return this.active = value;
    }
    setStatus(value) {
        return this.status = value;
    }
    setMessage(value) {
        return this.message = value;
    }
    setContact(value) {
        return this.contact = value;
    }
    setVendor(value) {
        return this.vendor = value;
    }
    setProgress(progress) {
        if (progress == null)
            return new Error("Progress object is missing or invalid");
        if (progress.current == null)
            return new Error("Progress (current) is missing or invalid");
        if (!progress.current.node.length)
            return new Error("Progress (current) Node (name) must be a valid string");
        if (progress.current.step < 0)
            return new Error("Progress (current) Step (node's step) must be a valid integer 0+");
        if (progress.detached == null)
            return new Error("Progress (detached) is missing or invalid");
        for (const k in progress.detached) {
            const item = progress.detached[k];
            if (item == null)
                return new Error("Progress (detached item) is missing or invalid");
            if (!item.node.length)
                return new Error("Progress (detached item) Node (name) must be a valid string");
            if (item.step < 0)
                return new Error("Progress (detached item) Step (node's step) must be a valid integer 0+");
        }
        this.progress = progress;
        this.need_sync = true;
        return null;
    }
    setTimestamp(value) {
        return this.timestamp = value;
    }
    refresh() {
        return this.timestamp = Math.floor(+new Date() / 1000);
    }
    send(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (data == null)
                throw new Error("Data can't be null");
            const message = new message_1.default(this.contact, this.token, this.origin, data);
            if (this.vendor != "")
                message.vendor = this.vendor;
            if (this.gateway.pushOutgoing(message) instanceof Error) {
                throw new Error("Can't push message to dispacther");
            }
            this.emitter.execute(emitter_1.EmitterEvents.ON_SEND_MESSAGE, { session: this, message });
            return "Message sent with success";
        });
    }
    end() {
        return this.status = false;
    }
}
exports.default = Session;
Session.EXPIRATION = 16 * 60 * 60;
//# sourceMappingURL=session.js.map