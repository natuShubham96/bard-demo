"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CourseState = void 0;
const definition_1 = require("./definition");
const flow_1 = require("./flow");
const logger_1 = __importDefault(require("../utils/logger"));
var CourseState;
(function (CourseState) {
    CourseState["DEFAULT"] = "default";
    CourseState["COMPLETED"] = "completed";
    CourseState["OVERLOAD"] = "overload";
})(CourseState = exports.CourseState || (exports.CourseState = {}));
class Course {
    constructor(flow, session) {
        this.flow = flow;
        this.session = session;
        const progress = this.session.getProgress();
        if (progress instanceof Error) {
            throw new Error(`Can't get session progress: '${progress.message}'`);
        }
        const node = this.flow.getNode(progress.current.node);
        if (node instanceof Error)
            throw new Error(`Can't get flow node '${progress.current.node}'`);
        const detached_progress = [];
        for (const k in progress.detached) {
            const item = progress.detached[k];
            const node = this.flow.getNode(item.node);
            if (node instanceof Error) {
                throw new Error(`Can't get flow node '${item.node}'`);
            }
            detached_progress.push({ node, step: item.step });
        }
        this.current_node = node;
        this.current_step = progress.current.step;
        this.detached_progress = detached_progress;
        this.lifes = 1;
        this.lock = false;
        this.current_flow_type = flow_1.FlowTypes.TRAILING;
        this.state = CourseState.DEFAULT;
    }
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            let status = false;
            if (this.state != CourseState.DEFAULT)
                return false;
            status = yield this.middleware(flow_1.FlowTypes.INCOMING);
            if (status && this.state != CourseState.OVERLOAD)
                return false;
            status = yield this.trailing();
            if (this.state == CourseState.COMPLETED)
                return false;
            status = yield this.middleware(flow_1.FlowTypes.OUTGOING);
            return true;
        });
    }
    call() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.current_step < 0)
                return false;
            let stack = 0;
            while (++stack < Course.MAX_STACK && this.current_step < this.current_node.chain.length && this.lifes > 0) {
                this.lock = false;
                this.state = CourseState.DEFAULT;
                const current_step = this.current_node.chain[this.current_step];
                try {
                    yield ((0, definition_1.isStepFunction)(current_step) ? current_step : current_step.action)(this.session, this);
                }
                catch (error) {
                    logger_1.default.log("error", `Step failed at '${this.current_node.name}' - step '${this.current_step}': ${error}`);
                }
                this.lifes--;
                // rewind detached progress
                if (this.current_flow_type == flow_1.FlowTypes.TRAILING && this.detached_progress.length > 0) {
                    if (this.current_step > this.current_node.chain.length - 1) {
                        const progress = this.detached_progress.pop();
                        if (progress != null && progress.node != null) {
                            const step = (progress.step || 0) + 1;
                            if (step < progress.node.chain.length) {
                                this.current_node = progress.node;
                                this.current_step = step;
                            }
                        }
                    }
                }
            }
            return true;
        });
    }
    trailing() {
        return __awaiter(this, void 0, void 0, function* () {
            this.current_flow_type = flow_1.FlowTypes.TRAILING;
            const status = yield this.call();
            this.setSessionProgress();
            return status;
        });
    }
    middleware(type) {
        return __awaiter(this, void 0, void 0, function* () {
            this.current_flow_type = type;
            const node = this.current_node;
            const step = this.current_step;
            const nodes = this.flow.getNodes(type);
            if (nodes instanceof Error)
                return false;
            this.lifes = 1;
            for (const [key, value] of nodes.entries()) {
                const node = value;
                this.current_node = node;
                this.current_step = 0;
                yield this.call();
                if (this.state != CourseState.OVERLOAD)
                    break;
            }
            let match = false;
            for (const [key, value] of nodes.entries()) {
                const node = value;
                if (node.name == this.current_node.name) {
                    match = true;
                    break;
                }
            }
            if (!match) {
                this.setSessionProgress();
                this.state = CourseState.OVERLOAD;
                return true;
            }
            this.current_node = node;
            this.current_step = step;
            return true;
        });
    }
    setSessionProgress() {
        this.session.setProgress({
            current: {
                node: this.current_node.name,
                step: this.current_step
            },
            detached: this.detached_progress.map((item) => {
                return { node: item.node.name, step: item.step };
            })
        });
    }
    next() {
        if (this.lock) {
            logger_1.default.log("warning", "[next] - Can't run any action in this step anymore.");
            return false;
        }
        this.lock = true;
        if (this.current_step >= (this.current_node.chain.length - 1)) {
            this.state = CourseState.OVERLOAD;
        }
        this.current_step++;
        this.lifes++;
        return true;
    }
    wait() {
        if (this.lock) {
            logger_1.default.log("warning", "[wait] - Can't run any action in this step anymore.");
            return false;
        }
        this.lock = true;
        this.current_step++;
        return true;
    }
    jump(step) {
        if (this.lock) {
            logger_1.default.log("warning", "[jump] - Can't run any action in this step anymore.");
            return false;
        }
        this.lock = true;
        if (typeof step === "string") {
            step = this.current_node.chain.findIndex(value => {
                return (0, definition_1.isStepFunction)(value) ? false : value.name === step;
            });
        }
        if (step < 0 || step > this.current_node.chain.length - 1) {
            logger_1.default.log("warning", "[jump] - Step is out of range.");
            return false;
        }
        this.lifes++;
        this.current_step = step;
        return true;
    }
    skip() {
        if (this.lock) {
            logger_1.default.log("warning", "[skip] - Can't run any action in this step anymore.");
            return false;
        }
        this.lock = true;
        this.lifes++;
        this.current_step = this.current_node.chain.length + 1;
        this.state = CourseState.OVERLOAD;
        return true;
    }
    again() {
        if (this.lock) {
            logger_1.default.log("warning", "[again] - Can't run any action in this step anymore.");
            return false;
        }
        this.lock = true;
        this.lifes++;
        return true;
    }
    reset() {
        if (this.lock) {
            logger_1.default.log("warning", "[reset] - Can't run any action in this step anymore.");
            return false;
        }
        this.lock = true;
        this.lifes++;
        this.current_step = 0;
        return true;
    }
    begin(name) {
        if (this.lock) {
            logger_1.default.log("warning", "[begin] - Can't run any action in this step anymore.");
            return false;
        }
        this.lock = true;
        if (this.current_flow_type !== flow_1.FlowTypes.TRAILING) {
            logger_1.default.log("warning", `[begin] - Can't call this action directly at incoming/outgoing layers.`);
            return false;
        }
        const node = this.flow.getNode(name);
        if (node instanceof Error) {
            logger_1.default.log("warning", `[begin] - Can't find node: '${name}'.`);
            return false;
        }
        this.detached_progress.push({
            node: this.current_node,
            step: this.current_step
        });
        this.current_node = node;
        this.current_step = 0;
        this.state = CourseState.DEFAULT;
        this.setSessionProgress();
        this.lifes++;
        return true;
    }
    replace(name, step) {
        if (this.lock) {
            logger_1.default.log("warning", "[replace] - Can't run any action in this step anymore.");
            return false;
        }
        this.lock = true;
        const node = this.flow.getNode(name);
        if (node instanceof Error) {
            logger_1.default.log("warning", `[replace] - Can't find node: '${name}'.`);
            return false;
        }
        if (step != null) {
            if (typeof step === "string") {
                step = node.chain.findIndex(value => {
                    return (0, definition_1.isStepFunction)(value) ? false : value.name === step;
                });
            }
            if (step < 0 || step > node.chain.length - 1) {
                logger_1.default.log("warning", "[replace] - Step is out of range.");
                return false;
            }
        }
        this.current_node = node;
        this.current_step = step || 0;
        this.detached_progress = [];
        this.current_flow_type = flow_1.FlowTypes.TRAILING;
        this.state = CourseState.DEFAULT;
        this.setSessionProgress();
        this.lifes++;
        return true;
    }
    end() {
        if (this.lock) {
            logger_1.default.log("warning", "[end] - Can't run any action in this step anymore.");
            return false;
        }
        this.lock = true;
        this.lifes = 0;
        this.state = CourseState.COMPLETED;
        const nodes = this.flow.getNodes();
        if (nodes instanceof Error) {
            logger_1.default.log("warning", `[end] - Can't find any nodes.`);
            return false;
        }
        const node = nodes.values().next().value;
        if (!node) {
            logger_1.default.log("warning", `[end] - Can't find node.`);
            return false;
        }
        this.current_node = node;
        this.current_step = 0;
        this.detached_progress = [];
        this.setSessionProgress();
        return true;
    }
}
exports.default = Course;
Course.MAX_STACK = 250;
//# sourceMappingURL=course.js.map