"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlowTypes = void 0;
const node_1 = __importDefault(require("./node"));
var FlowTypes;
(function (FlowTypes) {
    FlowTypes["INCOMING"] = "incoming";
    FlowTypes["TRAILING"] = "trailing";
    FlowTypes["OUTGOING"] = "outgoing";
})(FlowTypes = exports.FlowTypes || (exports.FlowTypes = {}));
class Flow {
    constructor() {
        this.nodes = new Map();
        this.setup();
    }
    setup() {
        for (const [item, value] of Object.entries(FlowTypes)) {
            this.nodes.set(value, new Map());
        }
    }
    getNode(name, type = FlowTypes.TRAILING) {
        const nodes = this.nodes.get(type);
        if (!nodes)
            return new Error("Can't get any node");
        for (const [key, value] of nodes.entries()) {
            if (value.name == name)
                return value;
        }
        return new Error("Can't get any node");
    }
    getNodes(type = FlowTypes.TRAILING) {
        const nodes = this.nodes.get(type);
        if (!(nodes && nodes.size))
            return new Error("Can't get any nodes");
        return nodes;
    }
    insertNode(name, chain, type = FlowTypes.TRAILING) {
        if (!(this.getNode(name, type) instanceof Error)) {
            return new Error("Node already exist");
        }
        const nodes = this.nodes.get(type);
        if (!nodes)
            return new Error("Nodes map do not exist");
        nodes.set(name, new node_1.default(name, chain));
        return null;
    }
}
exports.default = Flow;
//# sourceMappingURL=flow.js.map